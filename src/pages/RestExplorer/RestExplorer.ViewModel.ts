// ---- Utils
import {
  DecodeRequest,
  ReduceRequestURL,
  ReduceQueryParams,
  ReduceAuthHeader,
  ReduceAuthParameter,
} from "@workspaces/features/rest-explorer/utils";
import {
  createDeepCopy,
  moveNavigation,
  setContentTypeHeader,
} from "$lib/utils/helpers";
import { InitRequestTab } from "@common/utils";

// ---- DB
import type {
  CollectionDocument,
  TabDocument,
  WorkspaceDocument,
} from "$lib/database/app.database";

// ---- Repo
import { TabRepository } from "$lib/repositories/tab.repository";
import { CollectionRepository } from "$lib/repositories/collection.repository";
import { WorkspaceRepository } from "$lib/repositories/workspace.repository";

// ---- Interface
import type {
  Auth,
  Body,
  KeyValuePair,
  Path,
  Request,
  Response,
  State,
} from "$lib/utils/interfaces/request.interface";
import { BehaviorSubject, Observable } from "rxjs";
import { Events, ItemType, RequestDataset } from "$lib/utils/enums";
import type { CreateDirectoryPostBody } from "$lib/utils/dto";

// ---- Service
import { makeHttpRequestV2 } from "$lib/api/api.common";
import {
  insertCollection,
  insertCollectionDirectory,
  insertCollectionRequest,
  updateCollectionRequest,
} from "$lib/services/collection";

// ---- Events
import MixpanelEvent from "$lib/utils/mixpanel/MixpanelEvent";

// ---- Class Interface
interface RestRequest {
  updateRequestUrl: (url: string, effectQueryParams?: boolean) => void;
  updateRequestDescription: (description: string) => void;
  updateRequestName: (name: string) => void;
  updateRequestMethod: (method: string) => void;
  updateHeaders: (headers: KeyValuePair[]) => void;
  updateParams: (params: KeyValuePair[], effectURL?: boolean) => void;
  updateAutoGeneratedHeaders: (headers: KeyValuePair[]) => void;
  updateRequestState: (state: State) => void;
  updateRequestAuth: (auth: Auth) => void;
  updateRequestBody: (body: Body) => void;
  updateResponse: (response: Response) => void;
  clearResponse: () => void;
  sendRequest: () => void;
}

interface CollectionActions {
  readCollection: (uuid: string) => Promise<CollectionDocument>;
  readRequestOrFolderInCollection: (
    collectionId: string,
    uuid: string,
  ) => Promise<object>;
  readRequestInFolder: (
    collectionId: string,
    folderId: string,
    uuid: string,
  ) => Promise<unknown>;
  createFolder: (
    workspaceMeta: { id: string; name: string },
    collectionId: string,
    folderName: string,
  ) => Promise<{ status: string; data?: object; message?: string }>;
  createCollection: (
    workspaceMeta: { id: string; name: string },
    collectionName: string,
  ) => Promise<{ status: string; data?: object; message?: string }>;
  readWorkspace: (uuid: string) => Promise<WorkspaceDocument>;
}

interface CollectionMutation {
  addRequestOrFolderInCollection: (collectionId: string, items: object) => void;
  addCollection: (collection: object) => void;
  addRequestInFolder: (
    collectionId: string,
    folderId: string,
    request: object,
  ) => void;
}

interface SaveRequest {
  saveRequest: (
    saveDescriptionOnly?: boolean,
  ) => Promise<{ status: string; message?: string }>;
  saveAsRequest: (
    workspaceMeta: { id: string; name: string },
    path: { name: string; id: string; type: string }[],
    tabName: string,
    description: string,
    type: string,
  ) => Promise<
    { status: string; message?: string; data?: { id: string } } | unknown
  >;
}

class RestExplorerViewModel
  implements RestRequest, CollectionActions, CollectionMutation, SaveRequest
{
  /**
   * Repository
   */
  private collectionRepository = new CollectionRepository();
  private workspaceRepository = new WorkspaceRepository();
  /**
   * Utils
   */
  private _decodeRequest = new DecodeRequest();
  /**
   * Rest tools
   */
  private _httpMethod: BehaviorSubject<string> = new BehaviorSubject("");
  private _requestUrl: BehaviorSubject<string> = new BehaviorSubject("");
  private _requestName: BehaviorSubject<string> = new BehaviorSubject("");
  private _requestDescription: BehaviorSubject<string> = new BehaviorSubject(
    "",
  );
  private emptyHeaders: KeyValuePair[] = [];
  private _requestHeaders: BehaviorSubject<KeyValuePair[]> =
    new BehaviorSubject(this.emptyHeaders);
  private _requestParams: BehaviorSubject<KeyValuePair[]> = new BehaviorSubject(
    this.emptyHeaders,
  );
  private _requestAutoGeneratedHeaders: BehaviorSubject<KeyValuePair[]> =
    new BehaviorSubject(this.emptyHeaders);
  private _requestState: BehaviorSubject<State | object> = new BehaviorSubject(
    {},
  );
  private _requestAuth: BehaviorSubject<Auth | object> = new BehaviorSubject(
    {},
  );
  private _requestPath: BehaviorSubject<Path | object> = new BehaviorSubject(
    {},
  );
  private _requestBody: BehaviorSubject<Body | object> = new BehaviorSubject(
    {},
  );
  private _authHeader: BehaviorSubject<{
    key: string;
    value: string;
  }> = new BehaviorSubject({
    key: "",
    value: "",
  });
  private _authParameter: BehaviorSubject<{
    key: string;
    value: string;
  }> = new BehaviorSubject({ key: "", value: "" });
  private tabRepository = new TabRepository();
  private _tab: TabDocument;

  public constructor(doc: TabDocument) {
    if (doc?.isActive) {
      setTimeout(() => {
        const t = createDeepCopy(doc.toMutableJSON());
        delete t.isActive;
        this.tab = t;
        this.requestUrl = this.tab.property.request.url;
        this.requestName = this.tab.name;
        this.requestDescription = this.tab.description;
        this.httpMethod = this.tab.property.request.method;
        this.requestHeaders = this.tab.property.request.headers;
        this.requestParams = this.tab.property.request.queryParams;
        this.requestPath = this.tab.path;
        this.requestAutoGeneratedHeaders =
          this.tab.property.request.autoGeneratedHeaders;
        this.requestState = this.tab.property.request.state;
        this.requestAuth = this.tab.property.request.auth;
        this.requestBody = this.tab.property.request.body;
        this.response = this.tab.property.request.response;
        this.authHeader = new ReduceAuthHeader(
          this._requestState.getValue(),
          this._requestAuth.getValue(),
        ).getValue();
        this.authParameter = new ReduceAuthParameter(
          this._requestState.getValue(),
          this._requestAuth.getValue(),
        ).getValue();
      }, 0);
    }
  }

  public get tab() {
    return createDeepCopy(this._tab);
  }

  private set tab(value) {
    this._tab = value;
  }

  public get requestUrl(): Observable<string> {
    return this._requestUrl.asObservable();
  }

  private set requestUrl(value: string) {
    this._requestUrl.next(value);
  }

  public get authHeader(): Observable<{
    key: string;
    value: string;
  }> {
    return this._authHeader.asObservable();
  }

  private set authHeader(value: { key: string; value: string }) {
    this._authHeader.next(value);
  }

  public get authParameter(): Observable<{ key: string; value: string }> {
    return this._authParameter.asObservable();
  }

  private set authParameter(value: { key: string; value: string }) {
    this._authParameter.next(value);
  }

  public get httpMethod(): Observable<string> {
    return this._httpMethod.asObservable();
  }
  private set httpMethod(value: string) {
    this._httpMethod.next(value);
  }

  public get requestPath(): Observable<Path | object> {
    return this._requestPath.asObservable();
  }
  private set requestPath(value: Path) {
    this._requestPath.next(value);
  }

  public get requestName(): Observable<string> {
    return this._requestName.asObservable();
  }
  private set requestName(value: string) {
    this._requestName.next(value);
  }

  public get requestDescription(): Observable<string> {
    return this._requestDescription.asObservable();
  }
  private set requestDescription(value: string) {
    this._requestDescription.next(value);
  }

  public get requestHeaders(): Observable<KeyValuePair[]> {
    return this._requestHeaders.asObservable();
  }
  private set requestHeaders(value: KeyValuePair[]) {
    this._requestHeaders.next(value);
  }

  public get requestParams(): Observable<KeyValuePair[]> {
    return this._requestParams.asObservable();
  }
  private set requestParams(value: KeyValuePair[]) {
    this._requestParams.next(value);
  }

  public get requestAutoGeneratedHeaders(): Observable<KeyValuePair[]> {
    return this._requestAutoGeneratedHeaders.asObservable();
  }
  private set requestAutoGeneratedHeaders(value: KeyValuePair[]) {
    this._requestAutoGeneratedHeaders.next(value);
  }

  public get requestState(): Observable<State> {
    return this._requestState.asObservable();
  }
  private set requestState(value) {
    this._requestState.next(value);
  }

  public get requestAuth(): Observable<Auth> {
    return this._requestAuth.asObservable();
  }
  private set requestAuth(value) {
    this._requestAuth.next(value);
  }

  public get requestBody(): Observable<Body> {
    return this._requestBody.asObservable();
  }
  private set requestBody(value: Body) {
    this._requestBody.next(value);
  }

  public _response = new BehaviorSubject<Response | undefined>(undefined);

  public get response(): Observable<Response | undefined> {
    return this._response.asObservable();
  }
  private set response(value: Response) {
    this._response.next(value);
  }

  /**
   *
   * @param _url - request url
   * @param _effectQueryParams  - flag that effect request query parameter
   */
  public updateRequestUrl = async (
    _url: string,
    _effectQueryParams: boolean = true,
  ) => {
    const activeTab = this.tab;
    activeTab.property.request.url = _url;
    activeTab.isSaved = false;
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.requestUrl = _url;
    if (_effectQueryParams) {
      const reducedURL = new ReduceRequestURL(_url);
      this.updateParams(reducedURL.getQueryParameters(), false);
    }
  };

  /**
   *
   * @param _path - request path
   */
  private updateRequestPath = async (_path: Path) => {
    const activeTab = this.tab;
    activeTab.path = _path;
    activeTab.isSaved = false;
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.requestPath = _path;
  };

  /**
   *
   * @param _id - request mongo id
   */
  private updateRequestId = async (_id: string) => {
    const activeTab = this.tab;
    activeTab.id = _id;
    activeTab.isSaved = false;
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
  };

  /**
   *
   * @param _description - request description
   */
  public updateRequestDescription = async (_description: string) => {
    const activeTab = this.tab;
    activeTab.description = _description;
    activeTab.isSaved = false;
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.requestDescription = _description;
  };

  /**
   *
   * @param _name - request name
   */
  public updateRequestName = async (_name: string) => {
    const activeTab = this.tab;
    activeTab.name = _name;
    activeTab.isSaved = false;
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.requestName = _name;
  };

  /**
   *
   * @param method request method
   */
  public updateRequestMethod = async (method: string) => {
    const activeTab = this.tab;
    activeTab.property.request.method = method;
    activeTab.isSaved = false;
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.httpMethod = method;
  };

  /**
   *
   * @param _headers - request headers
   */
  public updateHeaders = async (_headers: KeyValuePair[]) => {
    const activeTab = this.tab;
    activeTab.property.request.headers = _headers;
    activeTab.isSaved = false;
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.requestHeaders = _headers;
  };

  /**
   *
   * @param _params - request query parameters
   * @param _effectURL - lag that effect request url
   */
  public updateParams = async (
    _params: KeyValuePair[],
    _effectURL: boolean = true,
  ) => {
    const activeTab = this.tab;
    activeTab.property.request.queryParams = _params;
    activeTab.isSaved = false;
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.requestParams = _params;
    if (_effectURL) {
      const reducedQueryParams = new ReduceQueryParams(_params);
      const reducedURL = new ReduceRequestURL(this._requestUrl.getValue());
      this.updateRequestUrl(
        reducedURL.getHost() + "?" + reducedQueryParams.getValue(),
        false,
      );
    }
  };

  /**
   *
   * @param headers - request auto generated headers
   */
  public updateAutoGeneratedHeaders = async (headers: KeyValuePair[]) => {
    const activeTab = this.tab;
    activeTab.property.request.autoGeneratedHeaders = headers;
    activeTab.isSaved = false;
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.requestAutoGeneratedHeaders = headers;
  };

  /**
   *
   * @param _state - request state
   */
  public updateRequestState = async (_state: State) => {
    const activeTab = this.tab;
    activeTab.property.request.state = {
      ...activeTab.property.request.state,
      ..._state,
    };
    activeTab.isSaved = false;
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.requestState = this.tab.property.request.state;
  };

  /**
   *
   * @param _auth - request auth
   */
  public updateRequestAuth = async (_auth: Auth) => {
    const activeTab = this.tab;
    activeTab.property.request.auth = {
      ...activeTab.property.request.auth,
      ..._auth,
    };
    activeTab.isSaved = false;
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.requestAuth = this.tab.property.request.auth;
    this.authHeader = new ReduceAuthHeader(
      this._requestState.getValue(),
      this._requestAuth.getValue(),
    ).getValue();
    this.authParameter = new ReduceAuthParameter(
      this._requestState.getValue(),
      this._requestAuth.getValue(),
    ).getValue();
  };

  /**
   *
   * @param _body - request body
   */
  public updateRequestBody = async (_body: Body) => {
    const activeTab = this.tab;
    activeTab.property.request.body = {
      ...activeTab.property.request.body,
      ..._body,
    };
    activeTab.isSaved = false;
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.requestBody = this.tab.property.request.body;
  };

  /**
   *
   * @param _response response
   */
  public updateResponse = async (_response: Response) => {
    const activeTab = this.tab;
    activeTab.property.request.response = _response;
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.response = _response;
  };

  /**
   * @description clear response of a request
   */
  public clearResponse = async () => {
    const response: Response = new InitRequestTab(
      UntrackedItems.UNTRACKED + uuidv4(),
      "UNTRACKED-",
    ).getValue().property.request.response;
    this.updateResponse(response);
  };

  /**
   * @description send request
   */
  public sendRequest = async () => {
    this.updateRequestState({ isSendRequestInProgress: true });
    const start = Date.now();

    const decodeData = this._decodeRequest.init(this.tab.property.request, []);
    makeHttpRequestV2(...decodeData)
      .then((response) => {
        if (response.isSuccessful === false) {
          this.updateResponse({
            body: "",
            headers: [],
            status: "Not Found",
            time: 0,
            size: 0,
          });
          this.updateRequestState({ isSendRequestInProgress: false });
        } else {
          const end = Date.now();
          const byteLength = new TextEncoder().encode(
            JSON.stringify(response),
          ).length;
          const responseSizeKB = byteLength / 1024;
          const duration = end - start;
          const responseBody = response.data.body;
          const temp = Object.entries(response?.data?.headers || {});
          const head = [];
          temp.forEach((elem) => {
            head.push({
              key: elem[0],
              value: elem[1],
            });
          });
          let responseHeaders = head;
          let responseStatus = response.data.status;
          const ct =
            this._decodeRequest.setResponseContentType(responseHeaders);
          this.updateRequestState({
            responseBodyLanguage: ct,
            isSendRequestInProgress: false,
          });

          const resData = {
            body: responseBody,
            headers: responseHeaders,
            status: responseStatus,
            time: duration,
            size: responseSizeKB,
          };

          this.updateResponse(resData);
        }
      })
      .catch((error) => {
        console.error(error);
        this.updateRequestState({ isSendRequestInProgress: false });

        this.updateResponse({
          body: "",
          headers: [],
          status: "Not Found",
          time: 0,
          size: 0,
        });
      });
  };

  /**
   *
   * @param uuid  - collection id
   * @returns - collection Document
   */
  public readCollection = (uuid: string): Promise<CollectionDocument> => {
    return this.collectionRepository.readCollection(uuid);
  };

  /**
   *
   * @param collectionId - collection id
   * @param uuid - request or folder id
   * @returns - request document
   */
  public readRequestOrFolderInCollection = (
    collectionId: string,
    uuid: string,
  ): Promise<object> => {
    return this.collectionRepository.readRequestOrFolderInCollection(
      collectionId,
      uuid,
    );
  };

  /**
   *
   * @param collectionId - collection id
   * @param folderId - folder id
   * @param uuid - request id
   * @returns - request document
   */
  public readRequestInFolder = (
    collectionId: string,
    folderId: string,
    uuid: string,
  ) => {
    return this.collectionRepository.readRequestInFolder(
      collectionId,
      folderId,
      uuid,
    );
  };

  /**
   *
   * @param _workspaceMeta - workspace meta data
   * @param _collectionId - collection id
   * @param _folderName - folder name
   * @returns - folder status message
   */
  public createFolder = async (
    _workspaceMeta: {
      id: string;
      name: string;
    },
    _collectionId: string,
    _folderName: string,
  ) => {
    let userSource = {};
    const _collection: CollectionDocument =
      await this.readCollection(_collectionId);
    if (_collection?.activeSync) {
      userSource = {
        currentBranch: _collection?.currentBranch,
        source: "USER",
      };
    }
    const directory: CreateDirectoryPostBody = {
      name: _folderName,
      description: "",
      ...userSource,
    };
    const res = await insertCollectionDirectory(
      _workspaceMeta.id,
      _collectionId,
      directory,
    );
    if (res.isSuccessful) {
      const latestRoute = {
        id: res.data.data.id,
      };
      return {
        status: "success",
        data: {
          latestRoute,
          collectionId: _collectionId,
          data: res.data.data,
          addRequestOrFolderInCollection: this.addRequestOrFolderInCollection,
        },
      };
    } else {
      return {
        status: "error",
        message: res.message,
      };
    }
  };

  /**
   *
   * @param _workspaceMeta - workspace meta data
   * @param _collectionName - collection name
   * @returns - collection status message
   */
  public createCollection = async (
    _workspaceMeta: {
      id: string;
      name: string;
    },
    _collectionName: string,
  ) => {
    const newCollection = {
      name: _collectionName,
      workspaceId: _workspaceMeta.id,
    };
    const res = await insertCollection(newCollection);
    if (res.isSuccessful) {
      const latestRoute = {
        id: res.data.data._id,
      };
      const storage = res.data.data;
      const _id = res.data.data._id;
      delete storage._id;
      storage.id = _id;
      storage.workspaceId = _workspaceMeta.id;
      MixpanelEvent(Events.CREATE_COLLECTION, {
        source: "SaveRequest",
        collectionName: res.data.data.name,
        collectionId: res.data.data._id,
      });
      return {
        status: "success",
        data: {
          latestRoute,
          storage,
          addCollection: this.addCollection,
        },
      };
    } else {
      return {
        status: "error",
        message: res.message,
      };
    }
  };

  /**
   * Save Request
   * @param saveDescriptionOnly - refers save overall request data or only description as a documentation purpose.
   * @returns save status
   */
  public saveRequest = async (saveDescriptionOnly = false) => {
    const componentData = this.tab;
    const { folderId, collectionId, workspaceId } = componentData.path;
    if (!workspaceId || !collectionId) {
      return {
        status: "error",
        message: "request is not a part of any workspace or collection",
      };
    }
    const _collection = await this.readCollection(collectionId);
    let userSource = {};
    if (_collection?.activeSync && componentData?.source === "USER") {
      userSource = {
        currentBranch: _collection?.currentBranch,
        source: "USER",
      };
    }
    const _id = componentData.id;
    let existingRequest;
    if (!folderId) {
      existingRequest = await this.readRequestOrFolderInCollection(
        collectionId,
        _id,
      );
    } else {
      existingRequest = await this.readRequestInFolder(
        collectionId,
        folderId,
        _id,
      );
    }
    const bodyType =
      componentData.property.request.state.dataset === RequestDataset.RAW
        ? componentData.property.request.state.raw
        : componentData.property.request.state.dataset;
    let expectedRequest: Request;
    let expectedMetaData;
    if (!saveDescriptionOnly) {
      // Save overall api
      expectedRequest = {
        method: componentData.property.request.method,
        url: componentData.property.request.url,
        body: componentData.property.request.body,
        headers: componentData.property.request.headers,
        queryParams: componentData.property.request.queryParams,
        auth: componentData.property.request.auth,
        selectedRequestBodyType: setContentTypeHeader(bodyType),
        selectedRequestAuthType: componentData.property.request.state?.auth,
      };
      expectedMetaData = {
        id: _id,
        name: componentData?.name,
        description: componentData?.description,
        type: ItemType.REQUEST,
      };
    } else {
      // Save api description only
      expectedRequest = {
        method: existingRequest?.request.method,
        url: existingRequest?.request.url,
        body: existingRequest?.request.body,
        headers: existingRequest?.request.headers,
        queryParams: existingRequest?.request.queryParams,
        auth: existingRequest?.request.auth,
        selectedRequestBodyType:
          existingRequest?.request?.selectedRequestBodyType,
        selectedRequestAuthType:
          existingRequest?.request?.selectedRequestAuthType,
      };
      expectedMetaData = {
        id: _id,
        name: existingRequest?.name,
        description: componentData?.description,
        type: ItemType.REQUEST,
      };
    }
    let folderSource;
    if (folderId) {
      folderSource = {
        folderId: folderId,
      };
    }

    const res = await updateCollectionRequest(_id, folderId, collectionId, {
      collectionId: collectionId,
      workspaceId: workspaceId,
      ...folderSource,
      ...userSource,
      items: {
        ...expectedMetaData,
        request: expectedRequest,
      },
    });
    if (res.isSuccessful) {
      const activeTab = this.tab;
      activeTab.isSaved = true;
      this.tab = activeTab;
      this.tabRepository.updateTab(activeTab.tabId, activeTab);
      if (!folderId) {
        this.collectionRepository.updateRequestOrFolderInCollection(
          collectionId,
          _id,
          res.data.data,
        );
      } else {
        this.collectionRepository.updateRequestInFolder(
          collectionId,
          folderId,
          _id,
          res.data.data,
        );
      }
      return {
        status: "success",
        message: res.message,
      };
    } else {
      return {
        status: "error",
        message: res.message,
      };
    }
  };

  /**
   *
   * @param uuid - workspace id
   * @returns workspace document
   */
  public readWorkspace = (uuid: string): Promise<WorkspaceDocument> => {
    return this.workspaceRepository.readWorkspace(uuid);
  };

  get collection() {
    return this.collectionRepository.getCollection();
  }

  set collection(e) {}

  /**
   *
   * @param collectionId - collection id
   * @param items - request or folder item
   */
  public addRequestOrFolderInCollection = (
    collectionId: string,
    items: object,
  ) => {
    this.collectionRepository.addRequestOrFolderInCollection(
      collectionId,
      items,
    );
  };

  /**
   *
   * @param collection - collection document
   */
  public addCollection = (collection: object) => {
    this.collectionRepository.addCollection(collection);
  };

  /**
   *
   * @param collectionId - collection id
   * @param folderId - folder id
   * @param request - request document
   */
  public addRequestInFolder = (
    collectionId: string,
    folderId: string,
    request: object,
  ): void => {
    this.collectionRepository.addRequestInFolder(
      collectionId,
      folderId,
      request,
    );
  };

  /**
   *
   * @param _workspaceMeta - workspace meta data
   * @param path - request stack path
   * @param tabName - request name
   * @param description - request description
   * @param type - save over all request or description only
   */
  public saveAsRequest = async (
    _workspaceMeta: {
      id: string;
      name: string;
    },
    path: {
      name: string;
      id: string;
      type: string;
    }[],
    tabName: string,
    description: string,
    type: string,
  ) => {
    const saveType = {
      SAVE_DESCRIPTION: "SAVE_DESCRIPTION",
    };
    const componentData = this.tab;
    let userSource = {};
    const _id = componentData.id;
    if (path.length > 0) {
      let existingRequest;
      if (path[path.length - 1].type === ItemType.COLLECTION) {
        existingRequest = await this.readRequestOrFolderInCollection(
          path[path.length - 1].id,
          _id,
        );
      } else if (path[path.length - 1].type === ItemType.FOLDER) {
        existingRequest = await this.readRequestInFolder(
          path[0].id,
          path[path.length - 1].id,
          _id,
        );
      }
      const randomRequest: TabDocument = new InitRequestTab(
        "UNTRACKED-",
        "UNTRACKED-",
      ).getValue();
      const request = !existingRequest
        ? randomRequest.property.request
        : existingRequest.request;
      const expectedRequest = {
        method:
          type === saveType.SAVE_DESCRIPTION
            ? request.method
            : componentData.property.request.method,
        url:
          type === saveType.SAVE_DESCRIPTION
            ? request.url
            : componentData.property.request.url,
        body:
          type === saveType.SAVE_DESCRIPTION
            ? request.body
            : componentData.property.request.body,
        headers:
          type === saveType.SAVE_DESCRIPTION
            ? request.headers
            : componentData.property.request.headers,
        queryParams:
          type === saveType.SAVE_DESCRIPTION
            ? request.queryParams
            : componentData.property.request.queryParams,
        auth:
          type === saveType.SAVE_DESCRIPTION
            ? request.auth
            : componentData.property.request.auth,
      };
      if (path[path.length - 1].type === ItemType.COLLECTION) {
        /**
         * handle request at collection level
         */
        const _collection = await this.readCollection(path[path.length - 1].id);
        if (_collection?.activeSync) {
          userSource = {
            currentBranch: _collection?.currentBranch,
            source: "USER",
          };
        }
        const res = await insertCollectionRequest({
          collectionId: path[path.length - 1].id,
          workspaceId: _workspaceMeta.id,
          ...userSource,
          items: {
            name: tabName,
            description,
            type: ItemType.REQUEST,
            request: expectedRequest,
          },
        });
        if (res.isSuccessful) {
          this.addRequestOrFolderInCollection(
            path[path.length - 1].id,
            res.data.data,
          );
          const expectedPath = {
            folderId: "",
            folderName: "",
            collectionId: path[path.length - 1].id,
            workspaceId: _workspaceMeta.id,
          };
          if (
            !componentData.path.workspaceId ||
            !componentData.path.collectionId
          ) {
            /**
             * Update existing request
             */
            this.updateRequestName(res.data.data.name);
            this.updateRequestDescription(res.data.data.description);
            this.updateRequestPath(expectedPath);
            this.updateRequestId(res.data.data.id);
            const activeTab = this.tab;
            activeTab.isSaved = true;
            this.tab = activeTab;
            this.tabRepository.updateTab(activeTab.tabId, activeTab);
          } else {
            /**
             * Create new copy of the existing request
             */
            const initRequestTab = new InitRequestTab(
              res.data.data.id,
              "UNTRACKED-",
            );
            initRequestTab.updateName(res.data.data.name);
            initRequestTab.updateDescription(res.data.data.description);
            initRequestTab.updatePath(expectedPath);
            initRequestTab.updateUrl(res.data.data.request.url);
            initRequestTab.updateMethod(res.data.data.request.method);
            initRequestTab.updateBody(res.data.data.request.body);
            initRequestTab.updateQueryParams(res.data.data.request.queryParams);
            initRequestTab.updateAuth(res.data.data.request.auth);
            initRequestTab.updateHeaders(res.data.data.request.headers);

            this.tabRepository.createTab(initRequestTab.getValue());
            moveNavigation("right");
          }
          return {
            status: "success",
            message: res.message,
            data: {
              id: res.data.data.id,
            },
          };
        } else {
          return {
            status: "error",
            message: res.message,
          };
        }
      } else if (path[path.length - 1].type === ItemType.FOLDER) {
        /**
         * handle request at folder level
         */
        const _collection = await this.readCollection(path[0].id);
        if (_collection?.activeSync) {
          userSource = {
            currentBranch: _collection?.currentBranch,
            source: "USER",
          };
        }
        const res = await insertCollectionRequest({
          collectionId: path[0].id,
          workspaceId: _workspaceMeta.id,
          folderId: path[path.length - 1].id,
          ...userSource,
          items: {
            name: path[path.length - 1].name,
            type: ItemType.FOLDER,
            items: {
              name: tabName,
              description,
              type: ItemType.REQUEST,
              request: expectedRequest,
            },
          },
        });
        if (res.isSuccessful) {
          this.addRequestInFolder(
            path[0].id,
            path[path.length - 1].id,
            res.data.data,
          );
          const expectedPath = {
            folderId: path[path.length - 1].id,
            folderName: path[path.length - 1].name,
            collectionId: path[0].id,
            workspaceId: _workspaceMeta.id,
          };
          if (
            !componentData.path.workspaceId ||
            !componentData.path.collectionId
          ) {
            this.updateRequestName(res.data.data.name);
            this.updateRequestDescription(res.data.data.description);
            this.updateRequestPath(expectedPath);
            this.updateRequestId(res.data.data.id);
            const activeTab = this.tab;
            activeTab.isSaved = true;
            this.tab = activeTab;
            this.tabRepository.updateTab(activeTab.tabId, activeTab);
          } else {
            const initRequestTab = new InitRequestTab(
              res.data.data.id,
              "UNTRACKED-",
            );
            initRequestTab.updateName(res.data.data.name);
            initRequestTab.updateDescription(res.data.data.description);
            initRequestTab.updatePath(expectedPath);
            initRequestTab.updateUrl(res.data.data.request.url);
            initRequestTab.updateMethod(res.data.data.request.method);
            initRequestTab.updateBody(res.data.data.request.body);
            initRequestTab.updateQueryParams(res.data.data.request.queryParams);
            initRequestTab.updateAuth(res.data.data.request.auth);
            initRequestTab.updateHeaders(res.data.data.request.headers);
            this.tabRepository.createTab(initRequestTab.getValue());
            moveNavigation("right");
          }
          return {
            status: "success",
            message: res.message,
            data: {
              id: res.data.data.id,
            },
          };
        } else {
          return {
            status: "error",
            message: res.message,
          };
        }
      }
      MixpanelEvent(Events.SAVE_API_REQUEST);
    }
  };
}

export default RestExplorerViewModel;
