import {
  DecodeRequest,
  ReduceRequestURL,
  ReduceQueryParams,
} from "@rest-explorer/utils";
import type {
  TabDocument,
  WorkspaceDocument,
} from "$lib/database/app.database";
import { TabRepository } from "$lib/repositories/tab.repository";
import { createDeepCopy, setContentTypeHeader } from "$lib/utils/helpers";
import { CollectionRepository } from "$lib/repositories/collection.repository";
import type {
  KeyValuePair,
  Response,
} from "$lib/utils/interfaces/request.interface";
import { generateSampleRequest } from "$lib/utils/sample";
import { BehaviorSubject, Observable } from "rxjs";
import { makeHttpRequest } from "$lib/api/api.common";
import { ItemType, RequestDataset } from "$lib/utils/enums";
import { updateCollectionRequest } from "$lib/services/collection";
import { WorkspaceRepository } from "$lib/repositories/workspace.repository";

class RestExplorerViewModel {
  private collectionRepository = new CollectionRepository();
  private _httpMethod: BehaviorSubject<string> = new BehaviorSubject("");
  private _requestUrl: BehaviorSubject<string> = new BehaviorSubject("");
  private _requestName: BehaviorSubject<string> = new BehaviorSubject("");
  private _requestDescription: BehaviorSubject<string> = new BehaviorSubject(
    "",
  );

  private emptyHeaders: KeyValuePair[] = [];
  private _requestHeaders: BehaviorSubject<KeyValuePair[]> =
    new BehaviorSubject(this.emptyHeaders);
  private _requestParams: BehaviorSubject<KeyValuePair[]> = new BehaviorSubject(
    this.emptyHeaders,
  );
  private _requestAutoGeneratedHeaders: BehaviorSubject<KeyValuePair[]> =
    new BehaviorSubject(this.emptyHeaders);
  private _requestState: BehaviorSubject<any> = new BehaviorSubject({});
  private _requestAuth: BehaviorSubject<any> = new BehaviorSubject({});
  private _requestBody: BehaviorSubject<any> = new BehaviorSubject({});
  private tabRepository = new TabRepository();
  private workspaceRepository = new WorkspaceRepository();
  private _tab: TabDocument;
  private _decodeRequest = new DecodeRequest();
  // create a behaviour subject for all the tabs
  public constructor() {
    // get active data from rxdb and find using ID And initiate the Rest Explorer
    this.tabRepository.getTabLs().then((res: TabDocument[]) => {
      res.forEach((doc) => {
        if (doc.isActive) {
          this.tab = createDeepCopy(doc.toMutableJSON());
          this.requestUrl = this.tab.property.request.url;
          this.requestName = this.tab.name;
          this.requestDescription = this.tab.description;
          this.httpMethod = this.tab.property.request.method;
          this.requestHeaders = this.tab.property.request.headers;
          this.requestParams = this.tab.property.request.queryParams;
          this.requestAutoGeneratedHeaders =
            this.tab.property.request.autoGeneratedHeaders;
          this.requestState = this.tab.property.request.state;
          this.requestAuth = this.tab.property.request.auth;
          this.requestBody = this.tab.property.request.body;
          this.response = this.tab.property.request.response;
        }
      });
    });
  }

  get activfeTab() {
    return this.tabRepository.getTab();
  }

  public get tab() {
    return createDeepCopy(this._tab);
  }

  private set tab(value) {
    this._tab = value;
  }

  public get requestUrl(): Observable<string> {
    return this._requestUrl.asObservable();
  }

  private set requestUrl(value: string) {
    this._requestUrl.next(value);
  }

  public get httpMethod(): Observable<string> {
    return this._httpMethod.asObservable();
  }
  private set httpMethod(value: string) {
    this._httpMethod.next(value);
  }

  public get requestName(): Observable<string> {
    return this._requestName.asObservable();
  }
  private set requestName(value: string) {
    this._requestName.next(value);
  }

  public get requestDescription(): Observable<string> {
    return this._requestDescription.asObservable();
  }
  private set requestDescription(value: string) {
    this._requestDescription.next(value);
  }

  public get requestHeaders(): Observable<KeyValuePair[]> {
    return this._requestHeaders.asObservable();
  }
  private set requestHeaders(value: KeyValuePair[]) {
    this._requestHeaders.next(value);
  }

  public get requestParams(): Observable<KeyValuePair[]> {
    return this._requestParams.asObservable();
  }
  private set requestParams(value: KeyValuePair[]) {
    this._requestParams.next(value);
  }

  public get requestAutoGeneratedHeaders(): Observable<KeyValuePair[]> {
    return this._requestAutoGeneratedHeaders.asObservable();
  }
  private set requestAutoGeneratedHeaders(value: KeyValuePair[]) {
    this._requestAutoGeneratedHeaders.next(value);
  }

  public get requestState(): Observable<any> {
    return this._requestState.asObservable();
  }
  private set requestState(value) {
    this._requestState.next(value);
  }

  public get requestAuth(): Observable<any> {
    return this._requestAuth.asObservable();
  }
  private set requestAuth(value) {
    this._requestAuth.next(value);
  }

  public get requestBody(): Observable<any> {
    return this._requestBody.asObservable();
  }
  private set requestBody(value) {
    this._requestBody.next(value);
  }

  public _response = new BehaviorSubject<Response | undefined>(undefined);

  public get response(): Observable<Response | undefined> {
    return this._response.asObservable();
  }
  private set response(value: Response) {
    this._response.next(value);
  }

  public updateRequestUrl = async (_url: string, _effectQueryParams = true) => {
    const activeTab = this.tab;
    activeTab.property.request.url = _url;
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.requestUrl = _url;
    if (_effectQueryParams) {
      const reducedURL = new ReduceRequestURL(_url);
      this.updateParams(reducedURL.getQueryParameters(), false);
    }
  };

  public updateRequestDescription = async (_description: string) => {
    const activeTab = this.tab;
    activeTab.description = _description;
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.requestDescription = _description;
  };

  public updateRequestName = async (_name: string) => {
    const activeTab = this.tab;
    activeTab.name = _name;
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.requestName = _name;
  };

  public updateRequestMethod = async (method: string) => {
    const activeTab = this.tab;
    activeTab.property.request.method = method;
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.httpMethod = method;
  };

  public updateHeaders = async (_headers: KeyValuePair[]) => {
    const activeTab = this.tab;
    activeTab.property.request.headers = _headers;
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.requestHeaders = _headers;
  };

  public updateParams = async (_params: KeyValuePair[], _effectURL = true) => {
    const activeTab = this.tab;
    activeTab.property.request.queryParams = _params;
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.requestParams = _params;
    if (_effectURL) {
      const reducedQueryParams = new ReduceQueryParams(_params);
      const reducedURL = new ReduceRequestURL(this._requestUrl.getValue());
      this.updateRequestUrl(
        reducedURL.getHost() + "?" + reducedQueryParams.getValue(),
        false,
      );
    }
  };

  public updateAutoGeneratedHeaders = async (headers: KeyValuePair[]) => {
    const activeTab = this.tab;
    activeTab.property.request.autoGeneratedHeaders = headers;
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.requestAutoGeneratedHeaders = headers;
  };

  public updateRequestState = async (_state: any) => {
    const activeTab = this.tab;
    activeTab.property.request.state = {
      ...activeTab.property.request.state,
      ..._state,
    };
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.requestState = this.tab.property.request.state;
  };

  public updateRequestAuth = async (_auth: any) => {
    const activeTab = this.tab;
    activeTab.property.request.auth = {
      ...activeTab.property.request.auth,
      ..._auth,
    };
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.requestAuth = this.tab.property.request.auth;
  };

  public updateRequestBody = async (_body: any) => {
    const activeTab = this.tab;
    activeTab.property.request.body = {
      ...activeTab.property.request.body,
      ..._body,
    };
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.requestBody = this.tab.property.request.body;
  };

  public updateResponse = async (_response: Response) => {
    const activeTab = this.tab;
    activeTab.property.request.response = _response;
    this.tab = activeTab;
    this.tabRepository.updateTab(activeTab.tabId, activeTab);
    this.response = _response;
  };

  public clearResponse = async (_response: string) => {
    const response = generateSampleRequest(
      UntrackedItems.UNTRACKED + uuidv4(),
      new Date().toString(),
    ).property.request.response;
    this.updateResponse(response);
  };

  public sendRequest = async () => {
    this.updateRequestState({ requestInProgress: true });
    let start = Date.now();

    const decodeData = this._decodeRequest.init(this.tab.property.request, []);
    makeHttpRequest(...decodeData)
      .then((response) => {
        if (response.isSuccessful === false) {
          this.updateResponse({
            body: "",
            headers: "",
            status: "Not Found",
            time: 0,
            size: 0,
          });
          this.updateRequestState({ requestInProgress: false });
        } else {
          let end = Date.now();
          const byteLength = new TextEncoder().encode(
            JSON.stringify(response),
          ).length;
          let responseSizeKB = byteLength / 1024;
          let duration = end - start;
          let responseBody = response.data.response;
          const temp = Object.entries(response?.data?.headers || {});
          const head = [];
          temp.forEach((elem) => {
            head.push({
              key: elem[0],
              value: elem[1],
            });
          });
          let responseHeaders = head;
          let responseStatus = response.data.status;
          const ct =
            this._decodeRequest.setResponseContentType(responseHeaders);
          this.updateRequestState({
            responseRaw: ct,
            requestInProgress: false,
          });

          const resData = {
            body: responseBody,
            headers: responseHeaders,
            status: responseStatus,
            time: duration,
            size: responseSizeKB,
          };

          this.updateResponse(resData);
        }
      })
      .catch((error) => {
        console.error(error);
        this.updateRequestState({ requestInProgress: false });

        this.updateResponse({
          body: "",
          headers: "",
          status: "Not Found",
          time: 0,
          size: 0,
        });
      });
  };

  public readCollection = (uuid: string): Promise<CollectionDocument> => {
    return this.collectionRepository.readCollection(uuid);
  };

  public readRequestOrFolderInCollection = (
    collectionId: string,
    uuid: string,
  ): Promise<CollectionItem> => {
    return this.collectionRepository.readRequestOrFolderInCollection(
      collectionId,
      uuid,
    );
  };

  public readRequestInFolder = (
    collectionId: string,
    folderId: string,
    uuid: string,
  ) => {
    return this.collectionRepository.readRequestInFolder(
      collectionId,
      folderId,
      uuid,
    );
  };

  public saveRequest = async (saveDescriptionOnly = false) => {
    const componentData = this.tab;
    const { folderId, collectionId, workspaceId } = componentData.path;
    if (!workspaceId && !collectionId) {
      return {
        status: "error",
        message: "request is not a part of any workspace",
      };
    }
    const _collection = await this.readCollection(collectionId);
    let userSource = {};
    if (_collection?.activeSync && componentData?.source === "USER") {
      userSource = {
        currentBranch: _collection?.currentBranch,
        source: "USER",
      };
    }
    const _id = componentData.id;
    let existingRequest;
    if (!folderId) {
      existingRequest = await this.readRequestOrFolderInCollection(
        collectionId,
        _id,
      );
    } else {
      existingRequest = await this.readRequestInFolder(
        collectionId,
        folderId,
        _id,
      );
    }
    const bodyType =
      componentData.property.request.state.dataset === RequestDataset.RAW
        ? componentData.property.request.state.raw
        : componentData.property.request.state.dataset;
    let expectedRequest;
    let expectedMetaData;
    if (!saveDescriptionOnly) {
      // Save overall api
      expectedRequest = {
        method: componentData.property.request.method,
        url: componentData.property.request.url,
        body: componentData.property.request.body,
        headers: componentData.property.request.headers,
        queryParams: componentData.property.request.queryParams,
        auth: componentData.property.request.auth,
        selectedRequestBodyType: setContentTypeHeader(bodyType),
        selectedRequestAuthType: componentData.property.request.state?.auth,
      };
      expectedMetaData = {
        id: _id,
        name: componentData?.name,
        description: componentData?.description,
        type: ItemType.REQUEST,
      };
    } else {
      // Save api description only
      expectedRequest = {
        method: existingRequest?.request.method,
        url: existingRequest?.request.url,
        body: existingRequest?.request.body,
        headers: existingRequest?.request.headers,
        queryParams: existingRequest?.request.queryParams,
        auth: existingRequest?.request.auth,
        selectedRequestBodyType:
          existingRequest?.request?.selectedRequestBodyType,
        selectedRequestAuthType:
          existingRequest?.request?.selectedRequestAuthType,
      };
      expectedMetaData = {
        id: _id,
        name: existingRequest?.name,
        description: componentData?.description,
        type: ItemType.REQUEST,
      };
    }
    let folderSource;
    if (folderId) {
      folderSource = {
        folderId: folderId,
      };
    }

    const res = await updateCollectionRequest(_id, folderId, collectionId, {
      collectionId: collectionId,
      workspaceId: workspaceId,
      ...folderSource,
      ...userSource,
      items: {
        ...expectedMetaData,
        request: expectedRequest,
      },
    });
    if (res.isSuccessful) {
      if (!folderId) {
        this.collectionRepository.updateRequestOrFolderInCollection(
          collectionId,
          _id,
          res.data.data,
        );
      } else {
        this.collectionRepository.updateRequestInFolder(
          collectionId,
          folderId,
          _id,
          res.data.data,
        );
      }
      return {
        status: "success",
        message: res.message,
      };
    } else {
      return {
        status: "error",
        message: res.message,
      };
    }
  };
  public readWorkspace = (uuid: string): Promise<WorkspaceDocument> => {
    return this.workspaceRepository.readWorkspace(uuid);
  };

  public getActiveWorkspace = () => {
    return this.workspaceRepository.getActiveWorkspace();
  };

  get collection() {
    return this.collectionRepository.getCollection();
  }

  public addRequestOrFolderInCollection = (
    collectionId: string,
    items: any,
  ) => {
    this.collectionRepository.addRequestOrFolderInCollection(
      collectionId,
      items,
    );
  };

  public addCollection = (collection) => {
    this.collectionRepository.addCollection(collection);
  };

  public saveAsRequest = async () => {
    // let userSource = {};
    // const _id = componentData.id;
    // isLoading = true;
    // if (path.length > 0) {
    //   let existingRequest;
    //   if (path[path.length - 1].type === ItemType.COLLECTION) {
    //     existingRequest =
    //       await collectionsMethods.readRequestOrFolderInCollection(
    //         path[path.length - 1].id,
    //         _id,
    //       );
    //   } else if (path[path.length - 1].type === ItemType.FOLDER) {
    //     existingRequest = await collectionsMethods.readRequestInFolder(
    //       path[0].id,
    //       path[path.length - 1].id,
    //       _id,
    //     );
    //   }
    //   const randomRequest: NewTab = generateSampleRequest(
    //     "id",
    //     new Date().toString(),
    //   );
    //   const request = !existingRequest
    //     ? randomRequest.property.request
    //     : existingRequest.request;
    //   const expectedRequest = {
    //     method:
    //       type === saveType.SAVE_DESCRIPTION
    //         ? request.method
    //         : componentData.property.request.method,
    //     url:
    //       type === saveType.SAVE_DESCRIPTION
    //         ? request.url
    //         : componentData.property.request.url,
    //     body:
    //       type === saveType.SAVE_DESCRIPTION
    //         ? request.body
    //         : componentData.property.request.body,
    //     headers:
    //       type === saveType.SAVE_DESCRIPTION
    //         ? request.headers
    //         : componentData.property.request.headers,
    //     queryParams:
    //       type === saveType.SAVE_DESCRIPTION
    //         ? request.queryParams
    //         : componentData.property.request.queryParams,
    //     auth:
    //       type === saveType.SAVE_DESCRIPTION
    //         ? request.auth
    //         : componentData.property.request.auth,
    //   };
    //   if (path[path.length - 1].type === ItemType.COLLECTION) {
    //     const _collection = await collectionsMethods.readCollection(
    //       path[path.length - 1].id,
    //     );
    //     if (_collection?.activeSync) {
    //       userSource = {
    //         currentBranch: _collection?.currentBranch,
    //         source: "USER",
    //       };
    //     }
    //     const res = await insertCollectionRequest({
    //       collectionId: path[path.length - 1].id,
    //       workspaceId: workspace.id,
    //       ...userSource,
    //       items: {
    //         name: tabName,
    //         description,
    //         type: ItemType.REQUEST,
    //         request: expectedRequest,
    //       },
    //     });
    //     if (res.isSuccessful) {
    //       if (type !== saveType.SAVE_DESCRIPTION) {
    //         notifications.success("API request saved");
    //       }
    //       collectionsMethods.addRequestOrFolderInCollection(
    //         path[path.length - 1].id,
    //         res.data.data,
    //       );
    //       const expectedPath = {
    //         folderId: "",
    //         folderName: "",
    //         collectionId: path[path.length - 1].id,
    //         workspaceId: workspace.id,
    //       };
    //       if (
    //         !componentData.path.workspaceId &&
    //         !componentData.path.collectionId
    //       ) {
    //         collectionsMethods.updateTab(expectedPath, "path", _id);
    //         collectionsMethods.updateTab(res.data.data.name, "name", _id);
    //         collectionsMethods.updateTab(
    //           res.data.data.description,
    //           "description",
    //           _id,
    //         );
    //         collectionsMethods.updateTab(res.data.data.id, "id", _id);
    //         if (type === saveType.SAVE_DESCRIPTION) {
    //           collectionsMethods.setRequestSave(
    //             true,
    //             "description",
    //             res.data.data.id,
    //           );
    //         } else {
    //           collectionsMethods.setRequestSave(true, "api", res.data.data.id);
    //           collectionsMethods.setRequestSave(
    //             true,
    //             "description",
    //             res.data.data.id,
    //           );
    //         }
    //       } else {
    //         let sampleRequest = generateSampleRequest(
    //           res.data.data.id,
    //           new Date().toString(),
    //         );
    //         sampleRequest.name = res.data.data.name;
    //         sampleRequest.description = res.data.data.description;
    //         sampleRequest.path = expectedPath;
    //         sampleRequest.property.request.save.api = true;
    //         sampleRequest.property.request.save.description = true;
    //         sampleRequest.property.request.url = res.data.data.request.url;
    //         sampleRequest.property.request.method =
    //           res.data.data.request.method;
    //         sampleRequest.property.request.body = res.data.data.request.body;
    //         sampleRequest.property.request.queryParams =
    //           res.data.data.request.queryParams;
    //         sampleRequest.property.request.auth = res.data.data.request.auth;
    //         sampleRequest.property.request.headers =
    //           res.data.data.request.headers;
    //         collectionsMethods.handleCreateTab(sampleRequest);
    //       }
    //       onFinish(res.data.data.id);
    //       onClick(false);
    //       navigateToWorkspace();
    //       isLoading = false;
    //     } else if (res.message === "Network Error") {
    //       onClick(false);
    //       notifications.error(res.message);
    //     } else {
    //       onClick(false);
    //       notifications.error("Failed tol save the request!");
    //     }
    //   } else if (path[path.length - 1].type === ItemType.FOLDER) {
    //     const _collection = await collectionsMethods.readCollection(path[0].id);
    //     if (_collection?.activeSync) {
    //       userSource = {
    //         currentBranch: _collection?.currentBranch,
    //         source: "USER",
    //       };
    //     }
    //     const res = await insertCollectionRequest({
    //       collectionId: path[0].id,
    //       workspaceId: workspace.id,
    //       folderId: path[path.length - 1].id,
    //       ...userSource,
    //       items: {
    //         name: path[path.length - 1].name,
    //         type: ItemType.FOLDER,
    //         items: {
    //           name: tabName,
    //           description,
    //           type: ItemType.REQUEST,
    //           request: expectedRequest,
    //         },
    //       },
    //     });
    //     if (res.isSuccessful) {
    //       if (type !== saveType.SAVE_DESCRIPTION) {
    //         notifications.success("API request saved");
    //       }
    //       collectionsMethods.addRequestInFolder(
    //         path[0].id,
    //         path[path.length - 1].id,
    //         res.data.data,
    //       );
    //       const expectedPath = {
    //         folderId: path[path.length - 1].id,
    //         folderName: path[path.length - 1].name,
    //         collectionId: path[0].id,
    //         workspaceId: workspace.id,
    //       };
    //       if (
    //         !componentData.path.workspaceId &&
    //         !componentData.path.collectionId
    //       ) {
    //         collectionsMethods.updateTab(expectedPath, "path", _id);
    //         collectionsMethods.updateTab(res.data.data.name, "name", _id);
    //         collectionsMethods.updateTab(
    //           res.data.data.description,
    //           "description",
    //           _id,
    //         );
    //         collectionsMethods.updateTab(res.data.data.id, "id", _id);
    //         if (type === saveType.SAVE_DESCRIPTION) {
    //           collectionsMethods.setRequestSave(
    //             true,
    //             "description",
    //             res.data.data.id,
    //           );
    //         } else {
    //           collectionsMethods.setRequestSave(true, "api", res.data.data.id);
    //           collectionsMethods.setRequestSave(
    //             true,
    //             "description",
    //             res.data.data.id,
    //           );
    //         }
    //       } else {
    //         let sampleRequest = generateSampleRequest(
    //           res.data.data.id,
    //           new Date().toString(),
    //         );
    //         sampleRequest.name = res.data.data.name;
    //         sampleRequest.description = res.data.data.description;
    //         sampleRequest.path = expectedPath;
    //         sampleRequest.property.request.save.api = true;
    //         sampleRequest.property.request.save.description = true;
    //         sampleRequest.property.request.url = res.data.data.request.url;
    //         sampleRequest.property.request.method =
    //           res.data.data.request.method;
    //         sampleRequest.property.request.body = res.data.data.request.body;
    //         sampleRequest.property.request.queryParams =
    //           res.data.data.request.queryParams;
    //         sampleRequest.property.request.auth = res.data.data.request.auth;
    //         sampleRequest.property.request.headers =
    //           res.data.data.request.headers;
    //         collectionsMethods.handleCreateTab(sampleRequest);
    //       }
    //       onFinish(res.data.data.id);
    //       onClick(false);
    //       navigateToWorkspace();
    //       isLoading = false;
    //     }
    //   }
    //   MixpanelEvent(Events.SAVE_API_REQUEST);
    // }
  };
}

export default RestExplorerViewModel;
